:- module(lists_of_structures).
:- export args / 3.
:- export terms_functor / 3.
:- export inserta / 4.
:- export insertz / 4.
:- export update / 4.
:- export partition_by_key / 5.
:- export prefix_by_key / 5.
:- export group_by_key / 3.
:- export group_with_key / 3.
:- export lists_structs / 2.
:- comment(categories, ["Data Structures"]).
:- comment(summary, "Operations on lists of Structures").
:- comment(author, "Joachim Schimpf").
:- comment(copyright, "Joachim Schimpf, 2013").
:- comment(date, "$Date: 2014/07/05 15:52:16 $").
:- comment(see_also, [hash : list_to_hash / 4, sort / 4, number_sort / 4, merge / 5, number_merge / 5, struct / 1]).
:- comment(desc, html("<p>\r\n    This library contains predicates that operate on lists of structures,\r\n    in particular structures where one argument can be considered a `key'.\r\n    Such lists are very common, and often occur in sorted form.\r\n    </p><p>\r\n    The ECLiPSe kernel and other libraries support such lists as well, e.g.\r\n<UL>\r\n    <LI>the sorting built-ins (sort/4, merge/5, number_sort/4, number_merge/5)\r\n    <LI>hash:list_to_hash/4 for turning such lists into hash tables\r\n</UL>\r\n    </p><p>\r\n    If you have declared your structures using the\r\n    :- local(struct(...)) declaration, then you can use field names to\r\n    identify the key arguments in all these predicates, e.g.\r\n<PRE>\r\n    :- local struct(emp(name,age,salary)).\r\n    ?- Emps = [emp{name:joe,salary:100}, emp{name:bob,salary:200}],\r\n       sort(salary of emp, >=, Emps, Descending),\r\n       args(name of emp, Descending, Names).\r\n    Emps = [emp(joe, _, 100), emp(bob, _, 200)]\r\n    Descending = [emp(bob, _, 200), emp(joe, _, 100)]\r\n    Names = [bob, joe]\r\n    yes\r\n</PRE>\r\n</p>")).
:- comment(args / 3, [summary : "Extract arguments from a list of structures", amode : (args(+, +, -) is det), args : ["Key" : "Key argument position (non-negative integer, or list of those)", "Structs" : "List of structures", "Args" : "Variable, or list of arguments"], see_also : [arg / 3], desc : html("<p>\r\n    Structs is a list of structures, and Args is a list of the Key'th\r\n    arguments of these structures.\r\n    </p><p>\r\n    This is equivalent to either\r\n<pre>\r\n    maplist(arg(Key), Structs, Args)\r\n</pre>\r\n    or\r\n<pre>\r\n    ( foreach(S,Structs), foreach(A,Args), param(Key) do arg(Key,S,A) )\r\n</pre>\r\n    </p>"), exceptions : [4 : "Structs is insufficiently instantiated", 6 : "Some structure in Structs does not have a Key'th argument"], eg : "\r\n    ?- args(2, [f(3,a),f(2,b),f(1,c)], Args).\r\n    Args = [a,b,c]\r\n    yes\r\n\r\n    % extract keys from pairs\r\n    ?- args(1, [a-1,a-2,b-2,c-2,c-5], Keys).\r\n    Keys = [a,a,b,c,c]\r\n    yes\r\n\r\n    % extract values from pairs\r\n    ?- args(2, [a-1,a-2,b-2,c-2,c-5], Values).\r\n    Values = [1,2,2,2,5]\r\n    yes\r\n"]).
:- comment(group_by_key / 3, [summary : "Partition a list into sublists by key", amode : (group_by_key(+, +, -) is det), args : ["Key" : "Key argument position (non-negative integer, or list of those)", "Structs" : "List of structures", "Grouped" : "Variable, or list of list of structures"], see_also : [group_with_key / 3, sort / 4, merge / 5], desc : html("<p>\r\n    The list Structs is grouped into maximal sublists of consecutive\r\n    elements with identical keys.  Concatenating all these sublists will\r\n    yield the original list.  If the original list was ordered according\r\n    to the Key'th argument, then the sublists represent a partitioning of\r\n    the original elements according to their different key values.\r\n    </p>"), exceptions : [4 : "Arguments are insufficiently instantiated", 5 : "Some argument or its components are of the wrong type", 6 : "Some structure does not have a Key'th argument"], eg : "\r\n    ?- group_by_key(1, [f(a,1),f(a,2),f(b,2),f(c,2),f(c,5)], Groups).\r\n    Groups = [[f(a,1),f(a,2)], [f(b,2)], [f(c,2),f(c,5)]]\r\n    Yes (0.00s cpu)\r\n\r\n    ?- group_by_key(2, [f(a,1),f(a,2),f(b,2),f(c,2),f(c,5)], Groups).\r\n    Groups = [[f(a,1)], [f(a,2),f(b,2),f(c,2)], [f(c,5)]]\r\n    Yes (0.00s cpu)\r\n\r\n    ?- group_by_key(1, [a-1,a-2,b-2,c-2,c-5], Groups).\r\n    Groups = [[a-1,a-2], [b-2], [c-2,c-5]]\r\n    Yes (0.00s cpu)\r\n\r\n"]).
:- comment(group_with_key / 3, [summary : "Partition a list into sublists by key", amode : (group_with_key(+, +, -) is det), args : ["Key" : "Key argument position (non-negative integer, or list of those)", "Structs" : "List of structures", "Grouped" : "Variable, or list of KeyVal-SubList structures"], see_also : [group_by_key / 3, sort / 4, merge / 5], desc : html("<p>\r\n    The list Structs is grouped into maximal sublists of consecutive elements\r\n    with identical keys, such that concatenating all these sublists would\r\n    yield the original list.  If the original list was ordered according\r\n    to the Key'th argument, then the sublists represent a partitioning of\r\n    the original elements according to their different key values.\r\n    </p><p>\r\n    The output argument Grouped is bound to a list of KeyVal-SubList pairs,\r\n    where KeyVal is the value of the Key'th argument that all the structures\r\n    in SubList have in common.\r\n    </p>"), exceptions : [4 : "Arguments are insufficiently instantiated", 5 : "Some argument or its components are of the wrong type", 6 : "Some structure does not have a Key'th argument"], eg : "\r\n    ?- group_with_key(1, [f(a,1), f(a,2), f(b,2), f(c,2), f(c,5)], Groups).\r\n    Groups = [a - [f(a,1), f(a,2)], b - [f(b,2)], c - [f(c,2),f(c,5)]]\r\n    Yes (0.00s cpu)\r\n\r\n    ?- group_with_key(2, [f(a,1), f(a,2), f(b,2), f(c,2), f(c,5)], Groups).\r\n    Groups = [1 - [f(a,1)], 2 - [f(a,2),f(b,2),f(c,2)], 5 - [f(c,5)]]\r\n    Yes (0.00s cpu)\r\n"]).
:- comment(inserta / 4, [summary : "Insert Struct into a sorted list", amode : (inserta(+, +, +, -) is det), args : ["Key" : "Key argument position (non-negative integer, or list of those)", "Struct" : "Structure", "Old" : "Ordered list of structures", "New" : "Ordered list of structures, or variable"], see_also : [merge / 5, sort / 4], desc : html("<p>\r\n    Inserts the compound term Struct into the ordered list Old, giving New.\r\n    The lists are both in ascending order (according to their elements' Key'th\r\n    argument), and may contain duplicates.  If Old already contains elements\r\n    with the same key as Struct, then Struct is inserted before those.\r\n    </p><p>\r\n    The list New is always one element longer than the list Old.\r\n    </p>"), exceptions : [4 : "Arguments are insufficiently instantiated", 5 : "Some argument or its components are of the wrong type", 6 : "Some structure does not have a Key'th argument"], eg : "\r\n    ?- inserta(1, f(2,new), [f(1,a),f(2,b),f(2,c),f(3,d)], New).\r\n    New = [f(1,a), f(2,new), f(2,b), f(2,c), f(3,d)]\r\n    Yes (0.00s cpu)\r\n\r\n"]).
:- comment(insertz / 4, [summary : "Insert Struct into a sorted list", amode : (insertz(+, +, +, -) is det), args : ["Key" : "Key argument position (non-negative integer, or list of those)", "Struct" : "Structure", "Old" : "Ordered list of structures", "New" : "Ordered list of structures, or variable"], see_also : [merge / 5, sort / 4], desc : html("<p>\r\n    Inserts the compound term Struct into the ordered list Old, giving New.\r\n    The lists are both in ascending order (according to their elements' Key'th\r\n    argument), and may contain duplicates.  If Old already contains elements\r\n    with the same key as Struct, then Struct is inserted after those.\r\n    </p><p>\r\n    The list New is always one element longer than the list Old.\r\n    </p>"), exceptions : [4 : "Arguments are insufficiently instantiated", 5 : "Some argument or its components are of the wrong type", 6 : "Some structure does not have a Key'th argument"], eg : "\r\n    ?- insertz(1, f(2,new), [f(1,a),f(2,b),f(2,c),f(3,d)], New).\r\n    New = [f(1,a), f(2,b), f(2,c), f(2,new), f(3,d)]\r\n    Yes (0.00s cpu)\r\n"]).
:- comment(lists_structs / 2, [summary : "Mapping between a structure of lists and a list of structures", amode : (lists_structs(+, -) is det), amode : (lists_structs(-, +) is det), args : ["Lists" : "Structure with list arguments, or variable", "Structs" : "List of structures, or variable"], see_also : [terms_functor / 3, args / 3], desc : html("<p>\r\n    Maps a single structure with functor F/N whose arguments are all lists\r\n    of length M into a single list of length M of F/N structures, and vice\r\n    versa.  The arguments of the K'th structure on the right hand side\r\n    correspond to the K'th list elements on the left hand side.\r\n    </p><p>\r\n    The main purpose of this predicate is to build a list of structures from\r\n    several lists of arguments.  The simplest example is building a Key-Value\r\n    pair list from corresponding lists of Keys and Values.\r\n    </p><p>\r\n    The reverse direction is used to extract multiple argument lists from a list\r\n    of structures.  The simplest example is getting the Keys and Values from\r\n    a Key-Value pair list.  However, if only a single argument list is wanted,\r\n    it is more appropriate to use args/3.\r\n    </p>"), exceptions : [4 : "Arguments are insufficiently instantiated", 5 : "Some argument or its components are of the wrong type", 6 : "Some structure does not have a Key'th argument"], eg : "\r\n    ?- lists_structs(f([a,b,c],[1,2,3],[x,y,z]), Structs).\r\n    Structs = [f(a,1,x), f(b,2,y), f(c,3,z)]\r\n    Yes (0.00s cpu)\r\n\r\n    ?- lists_structs(Lists, [f(a,1,x), f(b,2,y), f(c,3,z)]).\r\n    Lists = f([a,b,c], [1,2,3], [x,y,z])\r\n    Yes (0.00s cpu)\r\n\r\n    ?- Keys=[1,2,3], Vals=[a,b,c], lists_structs(Keys-Vals, Pairs).\r\n    Keys = [1, 2, 3]\r\n    Vals = [a, b, c]\r\n    Pairs = [1-a, 2-b, 3-c]\r\n    Yes (0.00s cpu)\r\n\r\n    ?- lists_structs(Lists, [1-a, 2-b, 3-c]).\r\n    Lists = [1,2,3] - [a,b,c]\r\n    Yes (0.00s cpu)\r\n"]).
:- comment(partition_by_key / 5, [summary : "Partition the elements of a list according to a key value", amode : (partition_by_key(+, +, +, -, -) is det), args : ["Key" : "Key argument position (non-negative integer, or list of those)", "Value" : "A term", "All" : "List of structures", "Matches" : "Variable, or list of structures", "Others" : "Variable, or list of structures"], see_also : [prefix_by_key / 5], desc : html("<p>\r\n    The list All is split into two sublists Matches and Others, such that\r\n    Matches contains the elements whose Key argument is identical (in the\r\n    sense of ==/2) to Value, and Others contains the remaining elements.  The\r\n    element order in the sublists corresponds to the order in the original list.\r\n    </p>"), exceptions : [4 : "Arguments are insufficiently instantiated", 5 : "Some argument or its components are of the wrong type", 6 : "Some structure does not have a Key'th argument"], eg : "\r\n    ?- partition_by_key(1, b, [f(a,1),f(b,2),f(c,3),f(b,4)], Bs, Ns).\r\n    Bs = [f(b,2), f(b,4)]\r\n    Ns = [f(a,1), f(c,3)]\r\n    Yes (0.00s cpu)\r\n"]).
:- comment(prefix_by_key / 5, [summary : "Get the maximum prefix of a list whose elements match a key value", amode : (prefix_by_key(+, +, +, -, -) is det), args : ["Key" : "Key argument position (non-negative integer, or list of those)", "Value" : "A term", "All" : "List of structures", "Prefix" : "Variable, or list of structures", "Rest" : "Variable, or list of structures"], see_also : [partition_by_key / 5], desc : html("<p>\r\n    The list All is split into two sublists Prefix and Rest, such that\r\n    Prefix contains all the leading elements of All whose Key argument is\r\n    identical to Value, and Rest contains the remainder of the list.\r\n    Concatenating the Prefix and Rest will yield the original list All.\r\n    </p>"), exceptions : [4 : "Arguments are insufficiently instantiated", 5 : "Some argument or its components are of the wrong type", 6 : "Some structure does not have a Key'th argument"], eg : "\r\n    ?- prefix_by_key(1, a, [f(a,1),f(a,2),f(c,3),f(b,4),f(a,5)], Prefix, Rest).\r\n    Prefix = [f(a,1), f(a,2)]\r\n    Rest = [f(c,3), f(b,4), f(a,5)]\r\n    Yes (0.00s cpu)\r\n\r\n    ?- prefix_by_key(1, b, [f(a,1),f(a,2),f(c,3),f(b,4),f(a,5)], Prefix, Rest).\r\n    Prefix = []\r\n    Rest = [f(a,1), f(a,2), f(c,3), f(b,4), f(a,5)]\r\n    Yes (0.00s cpu)\r\n\r\n"]).
:- comment(terms_functor / 3, [summary : "All list elements have the given functor or atomic value", amode : (terms_functor(+, -, -) is semidet), amode : (terms_functor(-, +, +) is multi), fail_if : "Not all list elements have the same functor", args : ["Structs" : "List of terms, or variable", "Name" : "Atomic or variable", "Arity" : "Integer or variable"], see_also : [functor / 3], desc : html("<p>\r\n    Structs is a list of terms which all have the same functor Name/Arity.\r\n    Operationally, this can be used to either check the functors of existing\r\n    structures in the list, or to bind uninstantiated list elements to\r\n    new structures.\r\n    </p><p>\r\n    This is equivalent (modulo nondeterminism) to\r\n<pre>\r\n    ( foreach(S,Structs), param(Name,Arity) do functor(S,Name,Arity) )\r\n</pre>\r\n    </p><p>\r\n    Note that, like in the underlying functor/3 predicate, Name can be\r\n    any atomic term (including number and string) if Arity is zero.\r\n    </p>"), exceptions : [4 : "Arguments are insufficiently instantiated", 5 : "Name is not atomic", 5 : "Arity is not an integer", 5 : "Arity is greater than 0 and Name is not an atom", 6 : "Some structure in Structs does not have a Key'th argument"], eg : "\r\n    % fill a list with structure skeletons\r\n    ?- length(Ss,3), terms_functor(Ss,f,2).\r\n    Ss = [f(_275,_276), f(_278,_279), f(_281,_282)]\r\n    Yes (0.00s cpu)\r\n\r\n    % check whether all elements have same toplevel functor\r\n    ?- terms_functor([f(a),f(b)], F, A).\r\n    F = f\r\n    A = 1\r\n    Yes (0.00s cpu)\r\n\r\n    % fill a list with an atomic term (arity 0)\r\n    ?- length(Ss,3), terms_functor(Ss,99,0).\r\n    Ss = [99, 99, 99]\r\n    Yes (0.00s cpu)\r\n\r\n"]).
:- comment(update / 4, [summary : "Incorporate Struct into a duplicate-free sorted list", amode : (update(+, +, +, -) is det), args : ["Key" : "Key argument position (non-negative integer, or list of those)", "Struct" : "Structure", "Old" : "Strictly ordered list of structures", "New" : "Strictly ordered list of structures, or variable"], see_also : [merge / 5, sort / 4], desc : html("<p>\r\n    Inserts the compound term Struct into the ordered list Old, giving New.\r\n    The lists are both in strictly ascending order (according to their\r\n    elements' Key'th argument), i.e. without duplicates.  If Old already\r\n    contains an element with the same key as Struct, then Struct replaces\r\n    this existing element.  Otherwise, Struct is inserted at the correct\r\n    position to maintain the list order.\r\n    </p><p>\r\n    The list New is either of the same length as Old, or one longer.\r\n    </p>"), exceptions : [4 : "Arguments are insufficiently instantiated", 5 : "Some argument or its components are of the wrong type", 6 : "Some structure does not have a Key'th argument"], eg : "\r\n    ?- update(1, f(2,b), [f(1,a),f(3,c)], New).\r\n    New = [f(1,a), f(2,b), f(3,c)]\r\n    Yes (0.00s cpu)\r\n\r\n    ?- update(1, f(2,new), [f(1,a),f(2,b),f(3,c)], New).\r\n    New = [f(1,a), f(2,new), f(3,c)]\r\n    Yes (0.00s cpu)\r\n"]).
